#if defined _timer_stocks_included
 #endinput
#endif
#define _timer_stocks_included

#if !defined DMG_GENERIC

#define DMG_GENERIC			0			// generic damage was done
#define DMG_CRUSH			(1 << 0)	// crushed by falling or moving object. 
										// NOTE: It's assumed crush damage is occurring as a result of physics collision, so no extra physics force is generated by crush damage.
										// DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics collision. You probably want DMG_CLUB instead.
#define DMG_BULLET			(1 << 1)	// shot
#define DMG_SLASH			(1 << 2)	// cut, clawed, stabbed
#define DMG_BURN			(1 << 3)	// heat burned
#define DMG_VEHICLE			(1 << 4)	// hit by a vehicle
#define DMG_FALL			(1 << 5)	// fell too far
#define DMG_BLAST			(1 << 6)	// explosive blast damage
#define DMG_CLUB			(1 << 7)	// crowbar, punch, headbutt
#define DMG_SHOCK			(1 << 8)	// electric shock
#define DMG_SONIC			(1 << 9)	// sound pulse shockwave
#define DMG_ENERGYBEAM		(1 << 10)	// laser or other high energy beam 
#define DMG_PREVENT_PHYSICS_FORCE		(1 << 11)	// Prevent a physics force 
#define DMG_NEVERGIB		(1 << 12)	// with this bit OR'd in, no damage type will be able to gib victims upon death
#define DMG_ALWAYSGIB		(1 << 13)	// with this bit OR'd in, any damage type can be made to gib victims upon death.
#define DMG_DROWN			(1 << 14)	// Drowning


#define DMG_PARALYZE		(1 << 15)	// slows affected creature down
#define DMG_NERVEGAS		(1 << 16)	// nerve toxins, very bad
#define DMG_POISON			(1 << 17)	// blood poisoning - heals over time like drowning damage
#define DMG_RADIATION		(1 << 18)	// radiation exposure
#define DMG_DROWNRECOVER	(1 << 19)	// drowning recovery
#define DMG_ACID			(1 << 20)	// toxic chemicals or acid burns
#define DMG_SLOWBURN		(1 << 21)	// in an oven

#define DMG_REMOVENORAGDOLL	(1<<22)		// with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed.
										// use this to kill an entity that you've already got a server-side ragdoll for

#define DMG_PHYSGUN			(1<<23)		// Hit by manipulator. Usually doesn't do any damage.
#define DMG_PLASMA			(1<<24)		// Shot by Cremator
#define DMG_AIRBOAT			(1<<25)		// Hit by the airboat's gun

#define DMG_DISSOLVE		(1<<26)		// Dissolving!
#define DMG_BLAST_SURFACE	(1<<27)		// A blast on the surface of water that cannot harm things underwater
#define DMG_DIRECT			(1<<28)
#define DMG_BUCKSHOT		(1<<29)		// not quite a bullet. Little, rounder, different.

#endif

stock bool:IsValidClient( client ) 
{
    if ( !( 1 <= client <= MaxClients ) || !IsClientInGame(client) ) 
        return false; 
     
    return true; 
} 

stock Timer_SecondsToTime(Float:seconds, String:buffer[], maxlength, precision)
{
	new t = RoundToFloor(seconds);
	
	new hour, mins;
	
	if (t >= 3600)
	{
		hour = RoundToFloor(t / 3600.0);
		t = t % 3600;
    }
	
	if (t >= 60)
	{
		mins = RoundToFloor(t / 60.0);
		t = t % 60;
    }

	Format(buffer, maxlength, "");
	
	if (hour)
		Format(buffer, maxlength, "%s%02d:", buffer, hour);
	
	Format(buffer, maxlength, "%s%02d:", buffer, mins);
	
	if (precision == 1)
		Format(buffer, maxlength, "%s%04.1f", buffer, float(t) + seconds - RoundToFloor(seconds));
	else if (precision == 2)
		Format(buffer, maxlength, "%s%05.2f", buffer, float(t) + seconds - RoundToFloor(seconds));
	else if (precision == 3)
		Format(buffer, maxlength, "%s%06.3f", buffer, float(t) + seconds - RoundToFloor(seconds));
	else 
		Format(buffer, maxlength, "%s%02d", buffer, t);
}

//thanks to Peace-Maker
stock bool:IsClientMovingBackwards(client)
{
	new Float:fVelocity[3];
	GetEntPropVector(client, Prop_Data, "m_vecAbsVelocity", fVelocity);
   
	new Float:fEyeAngles[3];
	GetClientEyeAngles(client, fEyeAngles);
	new Float:fViewDirection[3];
	GetAngleVectors(fEyeAngles, fViewDirection, NULL_VECTOR, NULL_VECTOR);
   
	NormalizeVector(fVelocity, fVelocity);
	NormalizeVector(fViewDirection, fViewDirection);
   
	if(GetVectorDotProduct(fVelocity, fViewDirection) < 0)
			return true;
   
	return false;
}

stock Float:GetClientMovingDirection(client)
{
	new Float:fVelocity[3];
	GetEntPropVector(client, Prop_Data, "m_vecAbsVelocity", fVelocity);
   
	new Float:fEyeAngles[3];
	GetClientEyeAngles(client, fEyeAngles);
	
	if(fEyeAngles[0] > 70.0) 
		fEyeAngles[0] = 70.0;
	else if(fEyeAngles[0] < -70.0) 
		fEyeAngles[0] = -70.0;
	
	new Float:fViewDirection[3];
	GetAngleVectors(fEyeAngles, fViewDirection, NULL_VECTOR, NULL_VECTOR);
   
	NormalizeVector(fVelocity, fVelocity);
	NormalizeVector(fViewDirection, fViewDirection);
	
	new Float:direction = GetVectorDotProduct(fVelocity, fViewDirection);
   
	return direction;
}

stock Block_MovementControl(client, bool:unblock = false)
{
	if(!unblock)
	{
		SetEntityFlags(client, GetEntityFlags(client) | FL_ATCONTROLS);
	}
	else
	{
		SetEntityFlags(client, GetEntityFlags(client) & ~FL_ATCONTROLS);
	}
}

stock StopPlayer(client)
{
	TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, Float:{0.0,0.0,-100.0});
}

stock ClearTimer(&Handle:timer)
{
	if(timer != INVALID_HANDLE)
	{
		KillTimer(timer);
		timer = INVALID_HANDLE;
	}
}

stock bool:ShouldHappen(chance)
{
	return (GetRandomInt(1, 100/chance)==1?true:false);
}

stock CS_GetValidSpawnTeam()
{
	new maxEnt = GetMaxEntities(), tcount, ctcount;
	decl String:sClassName[64];
	for (new i = MaxClients; i < maxEnt; i++)
	{
		if (IsValidEdict(i) && IsValidEntity(i) && GetEdictClassname(i, sClassName, sizeof(sClassName)))
		{
			if (StrEqual(sClassName, "info_player_terrorist"))
			{
				tcount++;
			}
			else if (StrEqual(sClassName, "info_player_counterterrorist"))
			{
				ctcount++;
			}
		}
	}
	
	if(tcount > 0) return CS_TEAM_T;
	else if(ctcount > 0) return CS_TEAM_CT;
	
	else return CS_TEAM_NONE;
}

stock GetClientBySteamID(String:steamid[])
{
	new String:authid[32];
	for(new i=1;i<=MaxClients;++i)
	{
		if(!IsClientInGame(i))
			continue;
		if(!IsClientAuthorized(i))
			continue;
		GetClientAuthString(i, authid, sizeof(authid));
		if(strcmp(authid, steamid)==0)
			return i;
	}
	return 0;
}

stock GetClientByIP(String:ip[])
{
	decl String:client_ip[16];
	for(new i=1;i<=MaxClients;++i)
	{
		if(!IsClientInGame(i))
			continue;
		GetClientIP(i, client_ip, sizeof(client_ip));
		if(strcmp(client_ip, ip)==0)
			return i;
	}
	return 0;
}

stock DealDamage(nClientVictim, nDamage, nClientAttacker = 0, nDamageType = DMG_GENERIC, String:sWeapon[] = "")
{
	if(	nClientVictim > 0 &&
			IsValidEntity(nClientVictim) &&
			IsClientInGame(nClientVictim) &&
			IsPlayerAlive(nClientVictim) &&
			nDamage > 0)
	{
		new EntityPointHurt = CreateEntityByName("point_hurt");
		if(EntityPointHurt != 0)
		{
			new String:sDamage[16];
			IntToString(nDamage, sDamage, sizeof(sDamage));

			new String:sDamageType[32];
			IntToString(nDamageType, sDamageType, sizeof(sDamageType));

			DispatchKeyValue(nClientVictim,			"targetname",		"war3_hurtme");
			DispatchKeyValue(EntityPointHurt,		"DamageTarget",		"war3_hurtme");
			DispatchKeyValue(EntityPointHurt,		"Damage",			sDamage);
			DispatchKeyValue(EntityPointHurt,		"DamageType",		sDamageType);
			if(!StrEqual(sWeapon, ""))
				DispatchKeyValue(EntityPointHurt,	"classname",		sWeapon);
			DispatchSpawn(EntityPointHurt);
			AcceptEntityInput(EntityPointHurt,		"Hurt",				(nClientAttacker != 0) ? nClientAttacker : -1);
			DispatchKeyValue(EntityPointHurt,		"classname",		"point_hurt");
			DispatchKeyValue(nClientVictim,			"targetname",		"war3_donthurtme");

			RemoveEdict(EntityPointHurt);
		}
	}
}

stock CheckVelocity(client, type, Float:maxspeed)
{
	if(maxspeed > 0.0)
	{
		new Float:fVelocity[3];
		GetEntPropVector(client, Prop_Data, "m_vecVelocity", fVelocity);
		
		if(fVelocity[0] == 0.0)
			fVelocity[0] = 1.0;
		if(fVelocity[1] == 0.0)
			fVelocity[1] = 1.0;
		if(fVelocity[2] == 0.0)
			fVelocity[2] = 1.0;
		
		new Float:currentspeed = SquareRoot(Pow(fVelocity[0],2.0)+Pow(fVelocity[1],2.0));
		
		// 0: slow
		if(type == 0)
		{
			maxspeed = currentspeed/2.0;
			new Float:Multpl = currentspeed / maxspeed;
			fVelocity[0] /= Multpl;
			fVelocity[1] /= Multpl;

			TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, fVelocity);
		}
		// 1: limit
		else if(type == 1)
		{
			if (currentspeed >= maxspeed)
			{
				new Float:Multpl = currentspeed / maxspeed;
				fVelocity[0] /= Multpl;
				fVelocity[1] /= Multpl;

				TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, fVelocity);
			}
		}
		// 2: bounce back
		else if(type == 2)
		{
			fVelocity[0] *= -2.0;
			fVelocity[1] *= -2.0;
			if(fVelocity[1] > 0.0 && fVelocity[1] < 200.0)
				fVelocity[1] = 200.0;
			else if(fVelocity[1] < 0.0 && fVelocity[1] > -200.0)
				fVelocity[1] = -200.0;
			if(fVelocity[2] > 0.0)
				fVelocity[2] *= -1.0;

			TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, fVelocity);
		}
		// 3: booster
		else if(type == 3)
		{
			fVelocity[0] = fVelocity[0]*1.5;
			fVelocity[1] = fVelocity[1]*1.5;
			
			TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, fVelocity);
		}
		// 4: full booster (500.0)
		else if(type == 4)
		{
			if (!(GetEntityFlags(client) & FL_ONGROUND))
			{
				new Float:Multpl = currentspeed / maxspeed;
				fVelocity[0] /= Multpl;
				fVelocity[1] /= Multpl;

				TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, fVelocity);
			}
		}
		// 5: push up/down
		else if(type == 5)
		{
			fVelocity[2] = maxspeed;
			TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, fVelocity);
		}
		// 6: push north/south
		else if(type == 5)
		{
			fVelocity[0] = maxspeed;
			TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, fVelocity);
		}
		// 7: push east/west
		else if(type == 5)
		{
			fVelocity[1] = maxspeed;
			TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, fVelocity);
		}
	}
}

stock GetAimOrigin(client, Float:hOrigin[3]) 
{
    new Float:vAngles[3], Float:fOrigin[3];
    GetClientEyePosition(client,fOrigin);
    GetClientEyeAngles(client, vAngles);

    new Handle:trace = TR_TraceRayFilterEx(fOrigin, vAngles, MASK_SHOT, RayType_Infinite, TraceEntityFilterPlayer);

    if(TR_DidHit(trace)) 
    {
        TR_GetEndPosition(hOrigin, trace);
        CloseHandle(trace);
        return 1;
    }

    CloseHandle(trace);
    return 0;
}

public bool:TraceEntityFilterPlayer(entity, contentsMask) 
{
    return entity > MaxClients;
}